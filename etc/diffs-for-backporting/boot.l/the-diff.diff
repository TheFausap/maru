--- minimal	2020-06-11 09:29:42.070331633 +0200
+++ ../../../boot.l	2020-06-11 09:28:43.454054994 +0200
@@ -1,8 +1,12 @@
+(define unit-testing? '(t))
+
 (define list (lambda args args))
 
 (define %print print)
 (define %dump  dump)
 
+(define error)
+
 (define %error
   (lambda args
     (set error abort)
@@ -11,15 +15,15 @@
     (%print "\n")
     (abort)))
 
-(define error
+(set error
   (lambda args
     (set error %error)
-    (%print "\nerror: ")
+    (%print "\n[31;1merror: ")
     (apply print args)
-    (%print "\n")
+    (%print "[m\n")
     (abort)))
 
 (define caar (lambda (x) (car (car x))))
 (define cadr (lambda (x) (car (cdr x))))
 (define cdar (lambda (x) (cdr (car x))))
 (define cddr (lambda (x) (cdr (cdr x))))
@@ -87,15 +124,30 @@
 		       (if (pair? object)
 			   (qq-element object)
 			 (list 'quote object))))
-      (lambda (expr)
+      (lambda (env expr)
 	(qq-object expr)))))
 
-(define define-form (form (lambda (name args . body)
-			    `(define ,name (form (lambda ,args ,@body))))))
+(define define-form (form (lambda (env name args . body)
+			    `(define ,name (form (lambda (*env* ,@args) ,@body))))))
 
 (define-form define-function (name args . body)
   `(define ,name (lambda ,args ,@body)))
 
+(define-form define-macro (name args . body)
+  `(define-form ,name ,args (cons 'let (cons () (macro-expand (zip-assocs ',args (list ,@args)) ',body)))))
+
+(define-function macro-expand (bindings exp)
+  (if (pair? exp)
+      (cons (macro-expand bindings (car exp))
+	    (macro-expand bindings (cdr exp)))
+    (if (symbol? exp)
+	(let ((a (assq exp bindings)))
+	  (if a (cdr a) exp))
+      exp)))
+
+(define-form define-constant (name value)
+  `(define ,name (form () (lambda args ',value))))
+
 (define-function list-length (list)
   (if (pair? list)
      (let ((len 1))
	(while (set list (cdr list)) (set len (+ len 1)))
	len)
     0))
 
 (define %list->array
@@ -112,13 +166,13 @@
 
 (define-function map-with (function list a)
   (if (pair? list)
       (let ((head (function (car list) a)))
 	(cons head (map-with function (cdr list) a)))))
  
-(define-form define-expand (type args . body)	`(set-array-at *expanders*   ,type (lambda ,args ,@body)))
-(define-form define-encode (type args . body)	`(set-array-at *encoders*    ,type (lambda ,args ,@body)))
-(define-form define-eval   (type args . body)	`(set-array-at *evaluators*  ,type (lambda ,args ,@body)))
-(define-form define-apply  (type args . body)	`(set-array-at *applicators* ,type (lambda ,args ,@body)))
+(set *expanders*   (array))	(define-form define-expand (type args . body)	`(set-array-at *expanders*   ,type (lambda ,args ,@body)))
+(set *encoders*    (array))	(define-form define-encode (type args . body)	`(set-array-at *encoders*    ,type (lambda ,args ,@body)))
+(set *evaluators*  (array))	(define-form define-eval   (type args . body)	`(set-array-at *evaluators*  ,type (lambda ,args ,@body)))
+(set *applicators* (array))	(define-form define-apply  (type args . body)	`(set-array-at *applicators* ,type (lambda ,args ,@body)))
 
 ;;; let*
  
@@ -166,25 +306,25 @@
 
 ;;; built-in types
 
 (define-structure <undefined>	())
 (define-structure <data>	())
 (define-structure <long>	(_bits))				(define-function long? (self) (= <long> (type-of self)))
 (define-structure <double>	(_bits))				(define-function double? (self) (= <double> (type-of self)))
 (define-structure <string>	(size _bits))
 (define-structure <symbol>	(_bits))
 (define-structure <pair>	(head tail source))
 (define-structure <_array>	())
 (define-structure <array>	(size _array))
-(define-structure <expr>	(defn env))
+(define-structure <expr>	(name defn ctx profile))		(define-function expr? (obj) (= <expr> (type-of obj)))
 (define-structure <form>	(function symbol))
 (define-structure <fixed>	(function))
 (define-structure <subr>	(_name _imp _sig _profile))
 (define-structure <variable>	(name value env index type))		(define-function variable? (obj) (= <variable> (type-of obj)))
 (define-structure <env>		(parent level offset bindings stable))
 (define-structure <context>	(home env bindings callee pc))
 
 ;;; selector
 
 (define-structure <selector> (name methods default))
 
 (define-function selector? (obj) (= <selector> (type-of obj)))

+(define-function <selector>-inherit (methods type)
+  (let ((method ())
+	(probe  type))
+    (while (and (set probe (array-at %structure-bases probe))
+		(not (set method (array-at methods probe)))))
+    ;; (and method (set (array-at methods type) method))	;; copy down the method for performance
+    method))
+
 (define-apply <selector> (self . arguments)
   (apply (or (array-at (<selector>-methods self) (type-of (car arguments)))
+	     (<selector>-inherit (<selector>-methods self) (type-of (car arguments)))
 	     (<selector>-default self))
 	 arguments))
 
@@ -224,19 +527,29 @@
     self))
 
 (define-function <selector>-add-method (self type method)
+  (and (expr? method)
+       (or (<expr>-name method)
+	   (set (<expr>-name method)
+		(concat-symbol (array-at %type-names type) (concat-symbol '. (<selector>-name self))))))
   (set-array-at (<selector>-methods self) type method))
 
 (define-form define-selector (name . default)
-  (or default (set default `(args (error "cannot apply selector "',name
-					 " to "(array-at %type-names (type-of (car args)))
+  (let ((def (defined? name)))
+    (if def
+	(if (selector? (<variable>-value def))
+	    (list 'quote <variable>-value def)
+	  (error name" already defined as non-selector: " (<variable>-value def)))
+      (let ()
+	(or default (set default `(args (error "selector "',name
+					       " has no method for "(array-at %type-names (type-of (car args)))
 					 ": "(cons (car args) (map name-of-type (map type-of (cdr args))))))))
-  `(define ,name (selector ',name (lambda ,@default))))
+  `(define ,name (selector ',name (lambda ,@default)))))))
 
 (define-selector add-method)
 
 (<selector>-add-method add-method <selector>
   (lambda (self type args body)
-    (<selector>-add-method self (eval type) (eval `(lambda ,args ,@body)))))
+    (<selector>-add-method self type (eval `(lambda ,args (with-instance-accessors ,type ,@body))))))
 
 ;;; print
 
@@ -288,6 +605,21 @@
 	    (print " ")))
       (print ")"))))
 
+(define-method do-dump <pair> ()
+  (if (= *globals* (cdr self))
+      (print "*globals*")
+    (let ()
+      (print "(")
+      (while self
+	(if (pair? self)
+	    (dump (car self))
+	  (let ()
+	    (print ". ")
+	    (print self)))
+	(if (set self (cdr self))
+	    (print " ")))
+      (print ")"))))
+
 (define-function dump-until (target arg)
   (let ((found (= target arg)))
     (if (pair? arg)
@@ -306,11 +638,13 @@
 	    (if (set arg (cdr arg))
 		(print " ")))
 	  (print ")"))
-      (print arg))
+      (dump arg))
     found))
 
-(define *backtrace*
+(if '()
+    (set *backtrace*
   (lambda (stack depth)
+	   (println "\n")
     (let ((posn (array)))
       (while (>= (set depth (- depth 1)) 0)
 	(let ((here (array-at stack depth)))
@@ -318,7 +652,11 @@
 	  (dump-until posn here)
 	  (print "\n")
 	  (set posn here))))
-    (exit 0)))
+	   (exit 1)))
+  ;;(println "; backtrace disabled")
+  )
+
+(define-function printf (fmt arg) (print (format fmt arg)))
 
 ;;; multimethod
 
@@ -405,0 +861,0 @@

(define-function max (a . rest)	(list-do b rest (set a (if (> b a) b a))) a)
(define-function min (a . rest)	(list-do b rest (set a (if (< b a) b a))) a)
(define-function sum (a . rest)	(list-do b rest (incr a b)) a)

(define-function align (value alignment)	(& (+ value (- alignment 1)) (- alignment)))
+
+;;; structural equality
+
+(define equal ()) ;; forward
+
+(define-function equal-lists (a b)
+  (and (equal (car a) (car b))
+       (equal (cdr a) (cdr b))))
+
+(set equal (lambda (a b)
+  (or (= a b)
+      (and (pair? a)
+	   (pair? b)
+	   (equal-lists a b)))))
+
+;;; unit testing
+
+(define-form unit-fail (expr)
+  `(error "UNIT FAIL "unit-name": "',expr))
+
+(define-form unit-assert (expr)
+  `(or ,expr (unit-fail ,expr)))
+
+(define-form unit-test (name . body)
+  (and unit-testing?
+       `(let ((unit-name ,name))
+	  ,@body)))
+
+;;; namespace
+
+(define *global* *globals*)
+
+(define-form define-namespace (name parent)	`(define ,name (environment ,parent)))
+
+(define-form namespace (name)			`(set *globals* ,name))
+
+;;; command line
+
+(define *load-path*)
+
+(and (= "-L" (car *arguments*))
+     (let ()
+       (pop *arguments*)
+       (set *load-path* (pop *arguments*))))
+
+(define-form next-argument () '(pop *arguments*))
+
+;;; load/save
+
+(define-function pval (expr)
+  (and (> (verbose) 0) (println expr))
+  (let ((result (eval expr)))
+    (and (> (verbose) 1) (println "=> "result))
+    result))
+
+(define-function find-and-read (name)
+  (or (and *load-path* (read (concat-string *load-path* name)))
+      (read name)))
+
+(define-function load (name)
+  (let ((exps (find-and-read name)))
+    (or exps (error "file not found or empty: "name))
+    (list-do expr exps (pval expr))))
+
+(define *loaded*)
+
+(define-function require (name)
+  (or (member? name *loaded*)
+      (let ()
+	(push *loaded* name)
+	(load name))))
+
+(define-method length <string> ()		(string-length self))
+(define-method length <array> ()		(array-length self))
+
+(define-method at <string> (index)		(string-at self index))
+(define-method at <array> (index)		(array-at self index))
+
+(define-method set-at <string> (index value)	(string-at self index))
+(define-method set-at <array> (index value)	(array-at self index))
+
+(define-function contents-to-file-named (string path . options)
+  (let ((f (or (open path "w")
+	       (error "cannot open for writing: "path)))
+	(p (or (car options) putc)))
+    (for (i 0 (length string)) (p (at string i) f))
+    (close f)))
+
+(define-function contents-of-file-named (path)
+  (let ((f (or (open path)
+	       (error "cannot open for reading: "path)))
+	(s (array))
+	(c))
+    (while (set c (getc f))
+      (array-append s c))
+    (close f)
+    (array->string s)))
