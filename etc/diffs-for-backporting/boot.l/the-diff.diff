--- minimal	2020-06-11 09:29:42.070331633 +0200
+++ ../../../boot.l	2020-06-11 09:28:43.454054994 +0200
@@ -1,8 +1,12 @@
+(define unit-testing? '(t))
+
 (define list (lambda args args))
 
 (define %print print)
 (define %dump  dump)
 
+(define error)
+
 (define %error
   (lambda args
     (set error abort)
@@ -11,15 +15,15 @@
     (%print "\n")
     (abort)))
 
-(define error
+(set error
   (lambda args
     (set error %error)
-    (%print "\nerror: ")
+    (%print "\n[31;1merror: ")
     (apply print args)
-    (%print "\n")
+    (%print "[m\n")
     (abort)))
 
 (define caar (lambda (x) (car (car x))))
 (define cadr (lambda (x) (car (cdr x))))
 (define cdar (lambda (x) (cdr (car x))))
 (define cddr (lambda (x) (cdr (cdr x))))
@@ -405,0 +861,0 @@

(define-function max (a . rest)	(list-do b rest (set a (if (> b a) b a))) a)
(define-function min (a . rest)	(list-do b rest (set a (if (< b a) b a))) a)
(define-function sum (a . rest)	(list-do b rest (incr a b)) a)

(define-function align (value alignment)	(& (+ value (- alignment 1)) (- alignment)))
+
+;;; structural equality
+
+(define equal ()) ;; forward
+
+(define-function equal-lists (a b)
+  (and (equal (car a) (car b))
+       (equal (cdr a) (cdr b))))
+
+(set equal (lambda (a b)
+  (or (= a b)
+      (and (pair? a)
+	   (pair? b)
+	   (equal-lists a b)))))
+
+;;; unit testing
+
+(define-form unit-fail (expr)
+  `(error "UNIT FAIL "unit-name": "',expr))
+
+(define-form unit-assert (expr)
+  `(or ,expr (unit-fail ,expr)))
+
+(define-form unit-test (name . body)
+  (and unit-testing?
+       `(let ((unit-name ,name))
+	  ,@body)))
+
+;;; namespace
+
+(define *global* *globals*)
+
+(define-form define-namespace (name parent)	`(define ,name (environment ,parent)))
+
+(define-form namespace (name)			`(set *globals* ,name))
+
+;;; command line
+
+(define *load-path*)
+
+(and (= "-L" (car *arguments*))
+     (let ()
+       (pop *arguments*)
+       (set *load-path* (pop *arguments*))))
+
+(define-form next-argument () '(pop *arguments*))
+
+;;; load/save
+
+(define-function pval (expr)
+  (and (> (verbose) 0) (println expr))
+  (let ((result (eval expr)))
+    (and (> (verbose) 1) (println "=> "result))
+    result))
+
+(define-function find-and-read (name)
+  (or (and *load-path* (read (concat-string *load-path* name)))
+      (read name)))
+
+(define-function load (name)
+  (let ((exps (find-and-read name)))
+    (or exps (error "file not found or empty: "name))
+    (list-do expr exps (pval expr))))
+
+(define *loaded*)
+
+(define-function require (name)
+  (or (member? name *loaded*)
+      (let ()
+	(push *loaded* name)
+	(load name))))
+
+(define-method length <string> ()		(string-length self))
+(define-method length <array> ()		(array-length self))
+
+(define-method at <string> (index)		(string-at self index))
+(define-method at <array> (index)		(array-at self index))
+
+(define-method set-at <string> (index value)	(string-at self index))
+(define-method set-at <array> (index value)	(array-at self index))
+
+(define-function contents-to-file-named (string path . options)
+  (let ((f (or (open path "w")
+	       (error "cannot open for writing: "path)))
+	(p (or (car options) putc)))
+    (for (i 0 (length string)) (p (at string i) f))
+    (close f)))
+
+(define-function contents-of-file-named (path)
+  (let ((f (or (open path)
+	       (error "cannot open for reading: "path)))
+	(s (array))
+	(c))
+    (while (set c (getc f))
+      (array-append s c))
+    (close f)
+    (array->string s)))
